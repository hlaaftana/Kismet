"i wrote this first part a little more complex and filler than i should have"
"there are clearer code examples if you scroll down"

"also keep in mind i don't have to put both quotes on the same line on every comment"
"im just doing it this way so intellij can parse it and syntax highlight it"

"you might have noticed these are string comments. you won't find comments in kismet along with"
"return, break, continue, and other purely imperative statements"
"however you can do"
don't "this so the string doesn't evaluate, and escapes like \u can be ignored"
quote "don't returns null, quote returns the expression if given 1 argument, or the list of expressions given multiple"

"this string is the value of this expression. there are multiple types of expressions:"

"block: contains multiple sequential expressions. surrounded by {} except at the top level of every script"
"the last value in a block (which is what we're in right now) is the return value of the block"

"call: contains 1 value expression and multiple argument expressions. surrounded by [] except at the top level with a newline"
"the value is called with the argument expressions. in the top level, if you write:"
a b c
"it parses the same as [a b c] where a b c are all atoms. some cases where this doesn't happen are:"
a
"parses as (a) which is an atom"
a b c
d
"parses as 2 expressions, [a b c] and (d). if it were written like this:"
[a b c
d]
"it would parse as [a b c d]"

"atom:"
"a string value surrounded by () unless it has no spaces."
"its value is its name searched in the 'context' which is where the variables are stored. so if you type"
a
"you get the variable with the name 'a'. also if you do"
a.b
"you get the property 'b' of variable 'a', and if you do"
a[0]
"you get the 0th element of variable 'a'."
"atoms can have characters like []{}(\"' if they dont start with them, so the following will parse correctly:"
isn't? 1 3

"string:"
"surrounded by double quotes or single quotes. contains text."

"number:"
"just numbers. can be one of 1, 1.0, 1e9, 1.0e9 and so on. info about negative numbers if you scroll down"

"java number types in kismet are like so:"
"BigInteger => Integer, BigDecimal => Float, long/Long => Int64, int/Integer => Int32,"
"short/Short => Int16, byte/Byte => Int8, float/Float => Float32, double/Double => Float64"

"normally numbers are parsed as Integers or Floats. however you can change this:"
[assert [of? 1 Integer]
        [of? 1i Integer]
        [of? 1i8 Int8]
        [of? 1i16 Int16]
        [of? 1i32 Int32]
        [of? 1i64 Int64]
        [of? 1f Float]
        [of? 1.0f Float]
        [of? 1f32 Float32]
        [of? 1f64 Float64]]

"note that this doesn't work:"
-1
"kismet thinks this is an atom. instead do:"
negative 1
"or just add 1 to the bits specifier, but this might be more confusing"
1i1

"you can define variables with :="
:= a 0
assert_is a 0

"you can set defined variables with ="
= a 1
assert_is a 1

"you can define variables which aren't defined and set them otherwise with ::="
::= a 2
assert_is a 2

::= b 1
assert_is b 1

"kismet doesn't have +=, *= and whatnot, but it does have |>="
:= a 2
|>= a [+ 5]

"|>= draws from |>, which evaluates a sequence of expressions with a value, where the value"
"is the 1st argument in a function call"
assert_is [|> a [* 3] logarithm] [logarithm [* a 3]]

"<| is the same as |> but the value is the last argument instead of the first"
assert_is [<| 5 [list 1 2 3 4] [subset? [list 2 4 5]]] [subset? [list 2 4 5] [list 1 2 3 4 5]]

"you can use a block to run multiple expressions more neatly"
|> [range 1 5] {
    product
    list
    * 2
    [[fn* {
        assert_is $0 120
        |> $1 class [is? Null]
    }]]
}

"you can define functions with fn"
:= get_four [fn 4]
assert_is [get_four] 4

"function arguments are like $0, $1... a list of all arguments is stored in $all"
:= swap2 [fn [pair $1 $0]]
assert_is [swap2 'a' 'b'] [pair 'b' 'a']

:= rev [fn [reverse $all]]
assert_is [rev 1 2 3 4 5] [list 5 4 3 2 1]

"the list function could be written in kismet directly as:"
:= list [fn $all]

"[defn name ...] is an alias for [:= name [fn ...]]"
defn can_drink? [>= $0.age 21]

"functions can have arguments"
defn plus [a b] [+ a b]

"and arguments can have checks"
defn factorial [[a [integer] [greater_equal 0]]] [
    if_else [zero? a] 1
        [product [range 1 a]]]

[assert_is [factorial 0] 1
           [factorial 1] 1
           [factorial 2] 2
           [factorial 3] 6
           [factorial 4] 24
           [factorial 5] 120
           [factorial 6] 720]

"kismet is dynamic, so functions can recurse or call other functions by getting their value at runtime"
defn factorial a [
    if_chain [zero? a] 1 [one? a] 1
        [* a [factorial [prev a]]]]

"however if you have to define function g inside function f, it will define g every time f is called"
"so there are 2 strategies we can take"

"if g needs arguments from f, it needs to be defined dynamically"
defn inverter f [fn [not [call f $all]]]

"if it doesn't, we can use the % operator which evaluates expressions at parse-time"
"therefore will be run in the main block before the script is ran,"
"and cannot use local function arguments or runtime variables"
"BUT will only be evaluated once and is mostly better for performance"
defn operation {
    %{
        defn secret_code {
            don't "Secret stuff!"
        }
    }
    [secret_code]
    "note: someone can save the function block, run it, then get the secret_code variable from "
    "the block variables, so we should undefine it to not let that happen"
    undef secret_code
}
"also the % operator divides numbers by 100 also at parse-time"

"fibonacci that accepts negative indexes:"
defn pown1 n [if_else [even? n] 1 [negative 1]]
defn fibonacci_nth n {
    if_else [or [zero? n] [one? n]] 1 {
        "[prev n] where n is a number is equal to [- n 1], same with [next n] and [+ n 1]"
        := r [prev [absolute n]]
        := x [if_else [negative? n] [pown1 r] [fibonacci_nth [prev r]]
        * [fibonacci_nth r] x
    }
}

"fibonacci that explicitly checks if number is 0 or positive:"
defn fibonacci_nth [[n [natural]]] {
    if_else [< n 2] 1 {
        := f [fibonacci_nth [- n 1]]
        := s [fibonacci_nth [- n 2]]
        + f s
    }
}

defn new_president_of_the_us {
    age [natural] [greater_equal 35]
    resident_country [is "United States"]
    resident_for_years [natural] [greater_equal 14]
    terms_served_before [natural] [less 0]
    has_a_penis [yes]
} "president constructor here"

defn can_be_president [try {
    call new_president_of_the_us $all
    yes
} e [if [is? "CheckFailedException" [java_class_name e]] no
     else [raise e]]]

"down here yet? cool, because i'm going to show a feature you shouldn't always use"
|>| 1 + 2 - 3
"this calls functions as every odd expression"
"if 2 function expressions are the same, it will call the function with more than 2 arguments"
assert_is [|>| 1 list 2 list 3 list 4] [list 1 2 3 4]
"note there is no operator precedence, it just evaluates left to right"
assert_is [|>| 1 list 2 * 3] [list 1 2 1 2 1 2]
assert_isn't [|>| 1 list 2 * 3] [list 1 6]
"|>| can be used again to reverse the effect"
|>| {
    6 * [|>| [
        product [range 1 5]
    ]] assert_is [product [1 range 6]]
}