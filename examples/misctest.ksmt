;; recursion
defn [foo (a: Int) (returns Int)] {
  or_else [< a 5] [foo [+ a 1]] a
}

assert_is 5 [foo 1]

;; path syntax
assert_is [1, 2, 3].[0] 1
assert "aa".<=("ab")

;; ??
dive {
  defn [`.property` x y] [cast Map x].[y]
  defn [`.property=` x y z] [cast Map x].[y]: z
  a: null
  assert_is [?? a.b.c] null
  a: {#"b": null}
  assert_is [?? a.b.c] null
  a.b: {#"c": null}
  assert_is [?? a.b.c] null
  a.b.c: 3
  assert_is [?? a.b.c] 3
}

;; double each
assert_is [let
  (result l: [], each i: [1, 2], each j: [3, 4])
  [add l (i, j)]] [(1, 3), (1, 4), (2, 3), (2, 4)]

;; parameter
dive {
  static T: [parameter_type]
  parametrize List[T] List[Int32]
  static [assert_is [unparam T] Int32]
}

dive {
  static T: [parameter_type Number]
  static U: [parameter_type]
  parametrize Tuple[Tuple[T, U], Int32] Tuple[Tuple[Int, String], Int32]
  static [assert_is [unparam T] Int]
  static [assert_is [unparam U] String]
}
