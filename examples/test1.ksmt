;; recursion
defn [foo (a: Int) (returns Int)] {
  or? [< a 5] [foo [+ a 1]] a
}

assert_is 5 [foo 1]

;; path syntax
assert_is [1, 2, 3].[0] 1
assert "aa".<=("ab")

;; ??
dive {
  defn [`.property` x y] [cast Map x].[y]
  defn [`.property=` x y z] [cast Map x].[y]: z
  a: null
  assert_is [?? a.b.c] null
  a: {#"b": null}
  assert_is [?? a.b.c] null
  a.b: {#"c": null}
  assert_is [?? a.b.c] null
  a.b.c: 3
  assert_is [?? a.b.c] 3
}

;; double each
assert_is [let
  (result l: [], each i: [1, 2], each j: [3, 4])
  [add l (i, j)]] [(1, 3), (1, 4), (2, 3), (2, 4)]