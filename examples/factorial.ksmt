functional: dive {
  defn [permutation (n: Int32) (r: Int32)] [cast Int32 [int32 [product [range [next [- n r]] n]]]]
  defn [factorial (n: Int32)] [permutation n n]
  defn [combination (n: Int32) (r: Int32)] [div [permutation n r] [factorial r]]

  assert_is [factorial 5i32] 120i32
  assert_is [permutation 4i32 2i32] 12i32
  assert_is [combination 6i32 3i32] 20i32
}

imperative: dive {
  defn [factorial (n: Int32)] {
    x: i: 1i32
    ;; for n x: * x it
    while [<= i n] {
      x: * x i
      incr i
    }
    x
  }

  defn [permutation (n: Int32) (r: Int32)] {
    x: 1i32
    i: + [- n r] 1i32
    while [<= i n] {
      |>= x [* i]
      incr i
    }
    x
  }

  defn [combination (n: Int32) (r: Int32)] [
    let [result x: 1i32, i: 0i32] [
      while [< i r] {
        x: / [* x [- n i]] [- r i]
        incr i
      }]]

  assert_is [factorial 5i32] 120i32
  assert_is [permutation 4i32 2i32] 12i32
  assert_is [combination 6i32 3i32] 20i32
}