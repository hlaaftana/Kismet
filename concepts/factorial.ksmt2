%operator {
  ;; = and : are predefined
  precedence_above Assignment Range
  infix .. Range
  infix (- +) Arithmetic1
  infix (* /) Arithmetic2
  infix < Comparison
}

functional = module {
  defn permutation(n r: Int) = product n - r + 1 .. n
  defn factorial(n: Int) = permutation n n
  defn combination(n r: Int) = div (permutation n r) (factorial r)
}

imperative = module {
  defn factorial(n: Int) {
    x = i = 1
    while i < n {
      x = x * (i = i + 1)
    }
    x
  }

  defn permutation(n r: Int) {
    x = 1
    i = next n - r
    while i < n {
      |>= x (* (|>= i (+ 1)))
    }
    x
  }

  defn combination(n r: Int) (
    let (result x = 1, i = 0) (
      while i < r {
        x = x * (n - i) / (r - i)
        incr i
      }))
}

assert_is (functional.factorial 5) (imperative.factorial 5) 120
assert_is functional.permutation(4, 2) (imperative.permutation 4 2) 12
assert_is (functional.combination 6 3) (imperative.combination 6 3) 20