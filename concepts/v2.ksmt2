# comments with #, dont know about multilines
# `do` for indented block, inferred in indents outside parens etc.
# calls are done like `foo a, b`, old kismet path syntax is retained so you can do `foo(a, b)` and `a.foo(b)`
# however to call `a.foo` you have to do `(a.foo b)`
# operators exist, always have more precedence than calls, so `foo a = b` is `foo(a = b)`
# operators can be words

def binary_search a: List[T], k: T -> i: Int32 # inferred do
  i = 0
  b = size a
  while i < b
    mid = half i + b
    if a[mid] < k, i = mid + 1 else b = mid
    # special syntax with keywords `then` and `else`
  unless i < a.size and a[i] == k, i = -1

assert
  3 is binary_search [1, 2, 3, 4, 5, 6], 4
  -1 is binary_search [3, 5, 1, 4, 1], 1

sub functional
  def permutation n: Int, r: Int do product n - r + 1 .. n
  def factorial n: Int do permutation n, n
  def combination n: Int, r: Int do (permutation n, r) div (factorial r)

sub imperative
  def factorial n: Int
    x = i = 1
    while i < n, x *= (i += 1)
    x

  def permutation n: Int, r: Int
    x = 1
    i = next n - r
    while i < n
      x |>= * (i |>= + 1)
    x

  def combination n: Int, r: Int -> x = 1 do for each i in 0..<r do while i < r, x = x * (n - i) / (r - i)

assert
  (functional.factorial)(5) is (imperative.factorial)(5) is 120
  (functional.permutation)(4, 2) is (imperative.permutation)(4, 2) is 12
  (functional.combination)(6, 3) is (imperative.combination)(6, 3) is 20
