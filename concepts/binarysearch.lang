Lessable has <(self, self): bool
Indexed has [](self, i: int): T for T

# you can do the above like

Lessable has (self < self): bool
Indexed has self[int]: T for T

binary_search(a: Indexed[T], k: T) is int
for T: Lessable, i = 0, c = b = size a do
  while i < b
    mid = half i + b
    case a[mid] < k
      i = next mid
    else
      b = mid
  case i < c or a[i] == k
    -1
  else
    i

assert
  binary_search(1..6, 4) is 3
  binary_search([3, 5, 1, 4, 1], 1) is -1

block functional
  permutation n, r is product n - r + 1 .. n
  factorial n is permutation n, n
  combination n, r is permutation(n, r) / factorial(r)

block imperative
  factorial n is x = 1 in
    for each i in 2..n
      x *= i

  permutation n r is x = 1 for i = n - r in
    while i < n
      x *= i .= next

  combination n r is x = 1 for i in 0..<r in
    x = x * (n - i) / (r - i)

assert
  (functional.factorial 5) is (imperative.factorial 5) is 120
  functional.permutation(4, 2) is (imperative.permutation 4 2) is 12
  (functional.combination 6 3) is (imperative.combination 6 3) is 20